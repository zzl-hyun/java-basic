# 8. final
final = const 값 변경 불가능

메모리 비효율 문제를 해결하기 위해 static final로 쓰는게 좋음

상수 = static final
대문자 사용 구분은 _ 관례임 ㅋㅋ

---

# 9. 상속 extends
자바는 다중 상속 지원X
다이아몬드 문제 땜에 그렇다네요 -> 엄마.move() 아빠.move()쓸지 오또케 알지?

## 상속과 메모리 구조 **중요**
**인스턴스 생성하면 상송 관계까지(super) 포함해서 인스턴스 생성 ㄷㄷ**
참조값 하나에 본인, 부모 인스턴스가 동시에 생성

자식.charge() 부모.charge() 누구꺼? **호출하는 놈의 타입(클래스)를 기준으로 선택**

현재 타입에서 메서드 못찾으면 상위 타입으로 가서 찾고 찾고 찾고 없으면 컴파일오류

**지금까지 설명한 상속과 메모리 구조는 반드시 이해해야 한다!**
- 상속 관계의 객체를 생성하면 그 내부에는 부모와 자식이 모두 생성된다.
- 상속 관계의 객체를 호출할 때, 대상 타입을 정해야 한다. 이때 호출자의 타입을 통해 대상 타입을 찾는다.
- 현재 타입에서 기능을 찾지 못하면 상위 부모 타입으로 기능을 찾아서 실행한다. 기능을 찾지 못하면 컴파일 오류
가 발생한다.

## 상속과 메서드 오버라이딩 = 재정의
부모타입의 기능을 자식에서 다르게 재정의 하고 싶을 때?

@Override 오 오버라이드

### 오버로딩(Overloading)과 오버라이딩(Overriding)
- 메서드 오버로딩: 메서드 이름이 같고 파라미터가 다른 메서드를 여러개 정의하는 것
- 오버 라이딩: 하위 클래스에서 상위 클래스의 메서드를 재정의하는 과정

## 메서드 오버라이딩 조건
- 메서드 이름 일치
- 메서드 매개변수 타입, 순서, 개수 일치
- 반환 타입 일치(하위 클래스 타입도 가능)
- 접근 제어자 더 제한적이면 안 됨
- 상위 보다 더 많은 throw를 선언 할 수 없음
- static, final, private은 오버라이딩 불가
- 생성자 오버라이딩 불가

## super 생성자
상위 클래스 생성자가 정의 되어있으면
하위 클래스에서 super()를 사용해 부모생성자를 호출해야 함


# 10. 다형성 (Polymorphism)
## 다형적 참조
부모 변수가 자식 인스턴스 참조
~~~
 Parent poly = new Child();
~~~
Chlid가 Parent 상속하니까 new로 생성될 때 Child, Parent가 동시 생성됨
이걸 Chlid가 아니라 Parent 타입으로 참조값을 받는거임

부모 타입은 모든 자식 타입을 참조할 수 있음 (타고 타고 타고 타고)
근데 자식으 기능은 호출 할 수 없음 왜냐 본인의 타입을 기준으로 호출하기 때문이고 상속 관계는 부모방향으로 올라갈 수는 있지만 내려갈 수는 없다.

근데 캐스팅 쓰면 삽가능

## 메서드오버라이딩
오버라이딩 하면 절대적인 우선권 가짐 손자라도 그게 실행됨