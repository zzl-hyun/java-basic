# 8. final
final = const 값 변경 불가능

메모리 비효율 문제를 해결하기 위해 static final로 쓰는게 좋음

상수 = static final
대문자 사용 구분은 _ 관례임 ㅋㅋ

---

# 9. 상속 extends
자바는 다중 상속 지원X
다이아몬드 문제 땜에 그렇다네요 -> 엄마.move() 아빠.move()쓸지 오또케 알지?

## 상속과 메모리 구조 **중요**
**인스턴스 생성하면 상송 관계까지(super) 포함해서 인스턴스 생성 ㄷㄷ**
참조값 하나에 본인, 부모 인스턴스가 동시에 생성

자식.charge() 부모.charge() 누구꺼? **호출하는 놈의 타입(클래스)를 기준으로 선택**

현재 타입에서 메서드 못찾으면 상위 타입으로 가서 찾고 찾고 찾고 없으면 컴파일오류

**지금까지 설명한 상속과 메모리 구조는 반드시 이해해야 한다!**
- 상속 관계의 객체를 생성하면 그 내부에는 부모와 자식이 모두 생성된다.
- 상속 관계의 객체를 호출할 때, 대상 타입을 정해야 한다. 이때 호출자의 타입을 통해 대상 타입을 찾는다.
- 현재 타입에서 기능을 찾지 못하면 상위 부모 타입으로 기능을 찾아서 실행한다. 기능을 찾지 못하면 컴파일 오류
가 발생한다.

## 상속과 메서드 오버라이딩 = 재정의
부모타입의 기능을 자식에서 다르게 재정의 하고 싶을 때?

@Override 오 오버라이드

### 오버로딩(Overloading)과 오버라이딩(Overriding)
- 메서드 오버로딩: 메서드 이름이 같고 파라미터가 다른 메서드를 여러개 정의하는 것
- 오버 라이딩: 하위 클래스에서 상위 클래스의 메서드를 재정의하는 과정

## 메서드 오버라이딩 조건
- 메서드 이름 일치
- 메서드 매개변수 타입, 순서, 개수 일치
- 반환 타입 일치(하위 클래스 타입도 가능)
- 접근 제어자 더 제한적이면 안 됨
- 상위 보다 더 많은 throw를 선언 할 수 없음
- static, final, private은 오버라이딩 불가
- 생성자 오버라이딩 불가

## super 생성자
상위 클래스 생성자가 정의 되어있으면
하위 클래스에서 super()를 사용해 부모생성자를 호출해야 함


# 10. 다형성 (Polymorphism)
## 다형적 참조
부모 변수가 자식 인스턴스 참조
~~~
 Parent poly = new Child();
~~~
Chlid가 Parent 상속하니까 new로 생성될 때 Child, Parent가 동시 생성됨
이걸 Chlid가 아니라 Parent 타입으로 참조값을 받는거임

부모 타입은 모든 자식 타입을 참조할 수 있음 (타고 타고 타고 타고)
근데 자식으 기능은 호출 할 수 없음 왜냐 본인의 타입을 기준으로 호출하기 때문이고 상속 관계는 부모방향으로 올라갈 수는 있지만 내려갈 수는 없다.

근데 캐스팅 쓰면 삽가능

## 메서드오버라이딩
오버라이딩 하면 절대적인 우선권 가짐 손자라도 그게 실행됨

# 11. 추상클래스
추상클래스는 new로 생성 못함

반드시 오버라이딩 해야 하는 메서드를 정의할 수 있음 -> 추상메서드
~~~
public abstract void sound();
~~~
순수 추상클래스 -> 인터페이스로 진화

# 12. 다형성과 설계
## 객체 지향 특징
- 추상화
- 캡슐화
- 상속
- 다형성

## 유연하고, 변경이 용이?
- 레고 블럭 조립하듯이
- 컴퓨터 부품 갈아 끼우듯이
- 컴포넌트를 쉽고 유연하게 변경하면서 개발할 수 있는 방법

## 역할과 구현을 분리
- 클라이언트는 대상의 역할(인터페이스)만 알면 된다.
- 클라이언트는 구현 대상의 내부 구조를 몰라도 된다.
- 클라이언트는 구현 대상의 내부 구조가 변경되어도 영향을 받지 않는다.
- 클라이언트느 구현 대상 자체를 변경해도 영향을 받지 않는다.

### 자바 언어
- 역할 = 인터페이스
- 구현 = 인터페이스를 구현한 클래스, 구현 객체
- 객체를 설계할 떄 역할과 구현을 명확히 분리
- 객체 설계시 역할(인터페이스)을 먼저 부여하고, 그 역할을 수행하는 구현 객체 만들기

### 한계
- 역할(인터페이스) 자체가 변하면, 클라이언트, 서버 모두에 큰 변경이 발생함
- 인터페이스를 안정적으로 잘 설계하는 것이 중요

## 정리
- 다형성이 가장 중요하다
- 디자인 패턴 대부분은 다형성을 활용하는 것
- 스프링의 핵심인 제어의 역전(IoC), 의존관계 주입(DI)도 결국 다형성 활용하는 것

## OCP(Open-Closed Principel)원칙
- Open for extension: 새로운 기능이 추가나 변경 사항이 생겼을 때, 기존 코드는 확장할 수 있어야 한다.
- Closed for modification: 기존의 코드는 수정되지 않아야 한다.

### 전략 패턴
알고리즘을 클라이언트 코드의 변경 없이 쉽게 교체할 수 있도록하는 디자인 패턴